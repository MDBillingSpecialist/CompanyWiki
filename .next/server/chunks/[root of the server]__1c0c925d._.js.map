{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/WoundCentrics/Desktop/Code%20Projects/Work%20Projects/Hippa/company-wiki/src/utils/mdx.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport matter from 'gray-matter';\nimport { compileMDX } from 'next-mdx-remote/rsc';\nimport rehypeHighlight from 'rehype-highlight';\nimport rehypeSlug from 'rehype-slug';\nimport remarkGfm from 'remark-gfm';\n\n// Define the content directory path\nconst contentDirectory = path.join(process.cwd(), 'content');\n\n// Define the frontmatter type\nexport interface Frontmatter {\n  title: string;\n  description?: string;\n  category?: string;\n  tags?: string[];\n  lastUpdated?: string;\n  [key: string]: any;\n}\n\nexport interface MDXContent {\n  frontmatter: Frontmatter;\n  content: React.ReactElement;\n  rawContent: string;\n  slug: string;\n}\n\nexport interface MDXListItem {\n  frontmatter: Frontmatter;\n  slug: string;\n  path: string;\n}\n\n/**\n * Get all content files from a directory recursively\n */\nexport function getAllContentFilePaths(dir: string = contentDirectory): string[] {\n  const files: string[] = [];\n  \n  // Get all files from the directory\n  const items = fs.readdirSync(dir, { withFileTypes: true });\n  \n  // Loop through each item\n  for (const item of items) {\n    const itemPath = path.join(dir, item.name);\n    \n    if (item.isDirectory()) {\n      // If directory, recurse and get files\n      files.push(...getAllContentFilePaths(itemPath));\n    } else if (item.isFile() && (item.name.endsWith('.md') || item.name.endsWith('.mdx'))) {\n      // If markdown file, add to list\n      files.push(itemPath);\n    }\n  }\n  \n  return files;\n}\n\n/**\n * Get content from a markdown file\n */\nexport async function getMDXContent(filePath: string): Promise<MDXContent> {\n  // Read the file\n  const fileContent = fs.readFileSync(filePath, 'utf8');\n  \n  // Extract frontmatter\n  const { data, content } = matter(fileContent);\n  \n  // Compile MDX\n  const compiled = await compileMDX({\n    source: content,\n    options: {\n      parseFrontmatter: true,\n      mdxOptions: {\n        rehypePlugins: [\n          rehypeHighlight,\n          rehypeSlug\n        ],\n        remarkPlugins: [\n          remarkGfm\n        ],\n      }\n    }\n  });\n  \n  // Get slug from file path\n  const relativePath = filePath.replace(contentDirectory, '');\n  const slug = relativePath\n    .replace(/^\\//, '') // Remove leading slash\n    .replace(/\\.(md|mdx)$/, ''); // Remove extension\n  \n  return {\n    frontmatter: data as Frontmatter,\n    content: compiled.content,\n    rawContent: content,\n    slug,\n  };\n}\n\n/**\n * Get all content metadata (frontmatter) from a directory\n */\nexport async function getAllContentMeta(directory: string = ''): Promise<MDXListItem[]> {\n  const dir = path.join(contentDirectory, directory);\n  \n  // Check if directory exists\n  if (!fs.existsSync(dir)) {\n    return [];\n  }\n  \n  // Get all markdown files in the directory\n  const files = getAllContentFilePaths(dir);\n  \n  // Extract frontmatter from each file\n  const contentMeta = files.map(filePath => {\n    const fileContent = fs.readFileSync(filePath, 'utf8');\n    const { data } = matter(fileContent);\n    \n    // Get slug from file path\n    const relativePath = filePath.replace(contentDirectory, '');\n    const slug = relativePath\n      .replace(/^\\//, '') // Remove leading slash\n      .replace(/\\.(md|mdx)$/, ''); // Remove extension\n    \n    return {\n      frontmatter: data as Frontmatter,\n      slug,\n      path: relativePath,\n    };\n  });\n  \n  // Sort by title\n  return contentMeta.sort((a, b) => {\n    if (a.frontmatter.title < b.frontmatter.title) return -1;\n    if (a.frontmatter.title > b.frontmatter.title) return 1;\n    return 0;\n  });\n}\n\n/**\n * Get content by slug\n */\nexport async function getContentBySlug(slug: string): Promise<MDXContent | null> {\n  // Log the slug for debugging\n  console.log(`Looking for content with slug: ${slug}`);\n  \n  // Construct possible file paths (.md or .mdx)\n  const mdPath = path.join(contentDirectory, `${slug}.md`);\n  const mdxPath = path.join(contentDirectory, `${slug}.mdx`);\n  const indexMdPath = path.join(contentDirectory, slug, 'index.md');\n  const indexMdxPath = path.join(contentDirectory, slug, 'index.mdx');\n  \n  // Check if any of the possible files exist\n  let filePath: string | null = null;\n  \n  // Try all possible file paths\n  if (fs.existsSync(mdPath)) {\n    console.log(`Found file at: ${mdPath}`);\n    filePath = mdPath;\n  } else if (fs.existsSync(mdxPath)) {\n    console.log(`Found file at: ${mdxPath}`);\n    filePath = mdxPath;\n  } else if (fs.existsSync(indexMdPath)) {\n    console.log(`Found index file at: ${indexMdPath}`);\n    filePath = indexMdPath;\n  } else if (fs.existsSync(indexMdxPath)) {\n    console.log(`Found index file at: ${indexMdxPath}`);\n    filePath = indexMdxPath;\n  } else {\n    console.error(`No content file found for slug: ${slug}`);\n    return null;\n  }\n  \n  // Read and parse the content\n  try {\n    return await getMDXContent(filePath);\n  } catch (error) {\n    console.error(`Error parsing content for slug ${slug}:`, error);\n    return null;\n  }\n}\n\n/**\n * Get content by section\n */\nexport async function getContentBySection(section: string): Promise<MDXListItem[]> {\n  return await getAllContentMeta(section);\n}\n\n/**\n * Organize content into sections\n */\nexport async function getContentSections(): Promise<Record<string, MDXListItem[]>> {\n  // Get all top-level directories in the content directory\n  const items = fs.readdirSync(contentDirectory, { withFileTypes: true });\n  const sections: Record<string, MDXListItem[]> = {};\n  \n  // For each directory, get content metadata\n  for (const item of items) {\n    if (item.isDirectory()) {\n      const sectionItems = await getContentBySection(item.name);\n      sections[item.name] = sectionItems;\n    }\n  }\n  \n  return sections;\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAEA,oCAAoC;AACpC,MAAM,mBAAmB,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AA4B3C,SAAS,uBAAuB,MAAc,gBAAgB;IACnE,MAAM,QAAkB,EAAE;IAE1B,mCAAmC;IACnC,MAAM,QAAQ,6FAAA,CAAA,UAAE,CAAC,WAAW,CAAC,KAAK;QAAE,eAAe;IAAK;IAExD,yBAAyB;IACzB,KAAK,MAAM,QAAQ,MAAO;QACxB,MAAM,WAAW,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI;QAEzC,IAAI,KAAK,WAAW,IAAI;YACtB,sCAAsC;YACtC,MAAM,IAAI,IAAI,uBAAuB;QACvC,OAAO,IAAI,KAAK,MAAM,MAAM,CAAC,KAAK,IAAI,CAAC,QAAQ,CAAC,UAAU,KAAK,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG;YACrF,gCAAgC;YAChC,MAAM,IAAI,CAAC;QACb;IACF;IAEA,OAAO;AACT;AAKO,eAAe,cAAc,QAAgB;IAClD,gBAAgB;IAChB,MAAM,cAAc,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,UAAU;IAE9C,sBAAsB;IACtB,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,CAAA,GAAA,yIAAA,CAAA,UAAM,AAAD,EAAE;IAEjC,cAAc;IACd,MAAM,WAAW,MAAM,CAAA,GAAA,wJAAA,CAAA,aAAU,AAAD,EAAE;QAChC,QAAQ;QACR,SAAS;YACP,kBAAkB;YAClB,YAAY;gBACV,eAAe;oBACb,qJAAA,CAAA,UAAe;oBACf,gJAAA,CAAA,UAAU;iBACX;gBACD,eAAe;oBACb,+IAAA,CAAA,UAAS;iBACV;YACH;QACF;IACF;IAEA,0BAA0B;IAC1B,MAAM,eAAe,SAAS,OAAO,CAAC,kBAAkB;IACxD,MAAM,OAAO,aACV,OAAO,CAAC,OAAO,IAAI,uBAAuB;KAC1C,OAAO,CAAC,eAAe,KAAK,mBAAmB;IAElD,OAAO;QACL,aAAa;QACb,SAAS,SAAS,OAAO;QACzB,YAAY;QACZ;IACF;AACF;AAKO,eAAe,kBAAkB,YAAoB,EAAE;IAC5D,MAAM,MAAM,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,kBAAkB;IAExC,4BAA4B;IAC5B,IAAI,CAAC,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,MAAM;QACvB,OAAO,EAAE;IACX;IAEA,0CAA0C;IAC1C,MAAM,QAAQ,uBAAuB;IAErC,qCAAqC;IACrC,MAAM,cAAc,MAAM,GAAG,CAAC,CAAA;QAC5B,MAAM,cAAc,6FAAA,CAAA,UAAE,CAAC,YAAY,CAAC,UAAU;QAC9C,MAAM,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,yIAAA,CAAA,UAAM,AAAD,EAAE;QAExB,0BAA0B;QAC1B,MAAM,eAAe,SAAS,OAAO,CAAC,kBAAkB;QACxD,MAAM,OAAO,aACV,OAAO,CAAC,OAAO,IAAI,uBAAuB;SAC1C,OAAO,CAAC,eAAe,KAAK,mBAAmB;QAElD,OAAO;YACL,aAAa;YACb;YACA,MAAM;QACR;IACF;IAEA,gBAAgB;IAChB,OAAO,YAAY,IAAI,CAAC,CAAC,GAAG;QAC1B,IAAI,EAAE,WAAW,CAAC,KAAK,GAAG,EAAE,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC;QACvD,IAAI,EAAE,WAAW,CAAC,KAAK,GAAG,EAAE,WAAW,CAAC,KAAK,EAAE,OAAO;QACtD,OAAO;IACT;AACF;AAKO,eAAe,iBAAiB,IAAY;IACjD,6BAA6B;IAC7B,QAAQ,GAAG,CAAC,CAAC,+BAA+B,EAAE,MAAM;IAEpD,8CAA8C;IAC9C,MAAM,SAAS,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,kBAAkB,GAAG,KAAK,GAAG,CAAC;IACvD,MAAM,UAAU,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,kBAAkB,GAAG,KAAK,IAAI,CAAC;IACzD,MAAM,cAAc,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,kBAAkB,MAAM;IACtD,MAAM,eAAe,iGAAA,CAAA,UAAI,CAAC,IAAI,CAAC,kBAAkB,MAAM;IAEvD,2CAA2C;IAC3C,IAAI,WAA0B;IAE9B,8BAA8B;IAC9B,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,SAAS;QACzB,QAAQ,GAAG,CAAC,CAAC,eAAe,EAAE,QAAQ;QACtC,WAAW;IACb,OAAO,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,UAAU;QACjC,QAAQ,GAAG,CAAC,CAAC,eAAe,EAAE,SAAS;QACvC,WAAW;IACb,OAAO,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,cAAc;QACrC,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,aAAa;QACjD,WAAW;IACb,OAAO,IAAI,6FAAA,CAAA,UAAE,CAAC,UAAU,CAAC,eAAe;QACtC,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,cAAc;QAClD,WAAW;IACb,OAAO;QACL,QAAQ,KAAK,CAAC,CAAC,gCAAgC,EAAE,MAAM;QACvD,OAAO;IACT;IAEA,6BAA6B;IAC7B,IAAI;QACF,OAAO,MAAM,cAAc;IAC7B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,KAAK,CAAC,CAAC,EAAE;QACzD,OAAO;IACT;AACF;AAKO,eAAe,oBAAoB,OAAe;IACvD,OAAO,MAAM,kBAAkB;AACjC;AAKO,eAAe;IACpB,yDAAyD;IACzD,MAAM,QAAQ,6FAAA,CAAA,UAAE,CAAC,WAAW,CAAC,kBAAkB;QAAE,eAAe;IAAK;IACrE,MAAM,WAA0C,CAAC;IAEjD,2CAA2C;IAC3C,KAAK,MAAM,QAAQ,MAAO;QACxB,IAAI,KAAK,WAAW,IAAI;YACtB,MAAM,eAAe,MAAM,oBAAoB,KAAK,IAAI;YACxD,QAAQ,CAAC,KAAK,IAAI,CAAC,GAAG;QACxB;IACF;IAEA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/WoundCentrics/Desktop/Code%20Projects/Work%20Projects/Hippa/company-wiki/src/app/api/content/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getContentBySlug } from '@/utils/mdx';\nimport path from 'path';\nimport fs from 'fs';\nimport matter from 'gray-matter';\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Get the content path from query params\n    const contentPath = request.nextUrl.searchParams.get('path');\n    \n    if (!contentPath) {\n      return new NextResponse(\n        JSON.stringify({ error: 'Missing content path parameter' }),\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\n      );\n    }\n    \n    // Get the slug from the path (remove extension)\n    const slug = contentPath.replace(/\\.md$/, '');\n    \n    // Use the existing utility to get content\n    const content = await getContentBySlug(slug);\n    \n    if (!content) {\n      return new NextResponse(\n        JSON.stringify({ error: 'Content not found' }),\n        { status: 404, headers: { 'Content-Type': 'application/json' } }\n      );\n    }\n    \n    // Return only the necessary data\n    return new NextResponse(\n      JSON.stringify({\n        frontmatter: content.frontmatter,\n        content: content.rawContent,\n        path: contentPath,\n      }),\n      { status: 200, headers: { 'Content-Type': 'application/json' } }\n    );\n  } catch (error) {\n    console.error('Error fetching content:', error);\n    return new NextResponse(\n      JSON.stringify({ error: 'Failed to fetch content' }),\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\n    );\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;;;;;AAKO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,yCAAyC;QACzC,MAAM,cAAc,QAAQ,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC;QAErD,IAAI,CAAC,aAAa;YAChB,OAAO,IAAI,gIAAA,CAAA,eAAY,CACrB,KAAK,SAAS,CAAC;gBAAE,OAAO;YAAiC,IACzD;gBAAE,QAAQ;gBAAK,SAAS;oBAAE,gBAAgB;gBAAmB;YAAE;QAEnE;QAEA,gDAAgD;QAChD,MAAM,OAAO,YAAY,OAAO,CAAC,SAAS;QAE1C,0CAA0C;QAC1C,MAAM,UAAU,MAAM,CAAA,GAAA,qHAAA,CAAA,mBAAgB,AAAD,EAAE;QAEvC,IAAI,CAAC,SAAS;YACZ,OAAO,IAAI,gIAAA,CAAA,eAAY,CACrB,KAAK,SAAS,CAAC;gBAAE,OAAO;YAAoB,IAC5C;gBAAE,QAAQ;gBAAK,SAAS;oBAAE,gBAAgB;gBAAmB;YAAE;QAEnE;QAEA,iCAAiC;QACjC,OAAO,IAAI,gIAAA,CAAA,eAAY,CACrB,KAAK,SAAS,CAAC;YACb,aAAa,QAAQ,WAAW;YAChC,SAAS,QAAQ,UAAU;YAC3B,MAAM;QACR,IACA;YAAE,QAAQ;YAAK,SAAS;gBAAE,gBAAgB;YAAmB;QAAE;IAEnE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,IAAI,gIAAA,CAAA,eAAY,CACrB,KAAK,SAAS,CAAC;YAAE,OAAO;QAA0B,IAClD;YAAE,QAAQ;YAAK,SAAS;gBAAE,gBAAgB;YAAmB;QAAE;IAEnE;AACF","debugId":null}}]
}